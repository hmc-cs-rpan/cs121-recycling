# Include routes helpers
<% environment.context_class.instance_eval { include Rails.application.routes.url_helpers } %>

@init_smooth_scrolling = ->
  # Smooth Scroll on clicking nav items
  $('nav a').click ->
    $href = $(this).attr('href')
    $('body').stop().animate { scrollTop: $($href).offset().top }, 1000
    false
  # back to top
  $('#toTop a').click ->
    $('body').animate { scrollTop: 0 }, 1000
    false
  # Parallaxing + add class active on scroll
  $(document).scroll ->
    # parallaxing
    $movebg = $(window).scrollTop() * -0.3
    $('.portion').css 'background-positionY', $movebg + 'px'
    # add class active to nav a on scroll
    scrollPos = $(document).scrollTop() + 100
    $('nav a').each ->
      currLink = $(this)
      refElement = $(currLink.attr('href'))
      if refElement.position().top <= scrollPos and refElement.position().top + refElement.height() > scrollPos
        $('nav a').removeClass 'active'
        currLink.addClass 'active'
      return
    # changing padding of nav a on scroll
    if scrollPos > 250
      $('nav a').addClass 'small'
      $('nav img').addClass 'move'
      $('nav span').removeClass 'movetext'
    else
      $('nav a').removeClass 'small'
      $('nav img').removeClass 'move'
      $('nav span').addClass 'movetext'
    return

###
Display only items belonging to the given category in the items picker.
If !force, then this founction is a noop if the given category is already displayed. Force can be
specified as a means of refreshing the items picker after an update.
###
@filter_by_category = (category_id, {force} = {}) ->
  force ?= false

  btn = $('#category' + category_id)
  if is_active(btn) and not force
    # We're already filtering by this category
    return
  clear_items()
  append_items_by_category category_id
  activate btn
  return


###
Display all items from all categories in the items picker.
###
@display_all_items = ->
  btn = $('#all_categories')
  if is_active btn
    # We're already displaying all items
    return
  clear_items()
  append_items all_items()
  activate btn
  return

###
Set or unset (based on value of select) active class on all the Items within a category
###
@select_all = (select) ->
  $('#items').children('li').each ->
    if is_active($(this)) != select
      toggle_active $(this)

###
Add a new item to the items picker based on the contents of #new-item-form
###
@save_new_item = ->
  item = form_to_json $('#new-item-form')

  if !item.name
    flash_error("Please enter a name for the item.", selector: '#new-item-errors')
    return
  if !item.category_id
    flash_error("Please choose a category for the item.", selector: '#new-item-errors')
    return

  # Tell the server to create the item
  get_json '<%= items_path %>', method: 'POST', data: { item: item }
    .on_success (res) ->
      # Close the dialog
      $('#new-item').modal('hide')

      # Add the new item to the items picker (maintaining sorted order) and filter by its category
      index = _.sortedIndex(items_by_category[item.category_id], item, 'name')
      items_by_category[item.category_id].splice index, 0, item
      filter_by_category(item.category_id, force: true)

      # Scroll to the new item
      first = $('#items li').first().position().top
      elem = $("#items li[name=\"#{item.name}\"]").position().top
      $('#items').scrollTop(elem - first);

      # And select it
      activate $("#items li[name=\"#{item.name}\"]")
    .on_error (err) ->
        flash_error(err, selector: '#new-item-errors')

###
Add a new bin to the city based on the contents of #new-bin-form
###
@save_new_bin = ->
  bin = form_to_json $('#new-bin-form')

  if !bin.name
    flash_error('Please enter a name for the bin.')
    return

  get_json '<%= bins_path %>', method: 'POST', data: { bin: bin }
    .on_success (res) ->
      # Add the new bin to our in-browser model
      res.bin.items ?= []
      bins.push res.bin
      # Clear the form
      $('#new-bin-form [name=name]').val('')

      refresh_bins()
    .on_error flash_error

###
Get the category_id by which we are currently filtering, or null if we are not.
###
@active_category = ->
  <% Category.all.each do |category| %>
    if is_active $("#category<%= category.id %>")
      return <%= category.id %>
  <% end %>
    else
      return null

###
Render the data contained in bins
###
@refresh_bins = ->
  last_bin = $("#bins li").last()
  $("#bins li").not(last_bin).remove()
  last_bin.detach()

  for bin in bins
    bin_li = $("<li class=\"bin-group-item\" name=\"#{bin.name}\">")
    $("#bins").append bin_li
    append_bin bin_li, bin

  $("#bins").append last_bin
  fit_to last_bin.find('.heading'), last_bin.find('input')

@click_new_bin = ->
  form = $("#new-bin-form")
  input = form.find('input')
  if input.val()
    form.submit()
  else
    input.focus()

###
Delete the specified bin from the database and the DOM.
###
delete_bin = (id) ->
  get_json "/bins/#{id}", method: 'DELETE'
    .on_success ->
      index = _.findIndex bins, (bin) -> bin.id == id
      if index == -1
        console.log "Unable to remove bin #{id} from GUI"
      else
        bins.splice index, 1
      refresh_bins()
    .on_error flash_error

###
Set the name of the bin with the given id.
###
rename_bin = (id, new_name) ->

  bin = _.find bins, (bin) -> bin.id == id
  unless bin?
    console.log "Could not find bin with id #{id}"
    return

  # Save old name so we can rollback if the transaction fails
  old_name = bin.name
  if !new_name || new_name == old_name
    # Nothing to do, just close the form
    refresh_bins()
    return
  bin.name = new_name

  get_json "/bins/#{id}", method: 'PATCH', data: { bin: bin }
    .on_success ->
      refresh_bins()
    .on_error flash_error
    .on_errors ->
      bin.name = old_name

###
Create a DOM structure representing a bin and append it to parent.
###
append_bin = (parent, bin) ->
  panel = $("<div class=\"bin\">")
  parent.append panel
  append_bin_header panel, bin
  append_bin_body panel, bin

###
Create and a DOM structure representing a given bin and append it to parent. The structure includes
the name of the bin, a button to edit the name, and a button to delete the bin.
###
append_bin_header = (parent, bin) ->
  title = $("<h3 class=\"title inline\">#{bin.name}</h3>")

  form = $("<form class=\"inline\">")
  input = $("<input type=\"text\" placeholder=\"#{bin.name}\" class=\"form-control\">")
  input.blur -> form.submit() # Submit form on focus out
  form.append input
  form.submit (e) ->
    e.preventDefault()
    rename_bin bin.id, input.val()

  edit_btn = $("<button type=\"button\" class=\"icon\">")
  edit_btn.append $("<span class=\"glyphicon glyphicon-pencil\">")
  edit_btn.click ->
    title.html("").append(form)
    input.focus()

  delete_btn = $("<button type=\"button\" class=\"close\">&times;</button>")
  delete_btn.click ->
    delete_bin(bin.id)

  heading = $('<div class="heading">').append edit_btn, title, delete_btn

  parent.append heading

  # Make the heading large enough to fit the form
  fit_to heading, form

###
Create a DOM structure representing the items in a given bin and append it to parent.
###
append_bin_body = (parent, bin) ->
  list = $('<ul class="body scrollable-list">')
  for item in bin.items
    list.append create_button item.name

  parent.append list

is_active = (elem) ->
  elem.hasClass 'active'

###
Remove all items from the items picker.
###
clear_items = ->
  $('#items').empty()

  # Unselect the category filter button
  $('#categories').children('li').each -> deactivate $(this)

###
Append all items from the given category to the items picker.
###
append_items_by_category = (category_id) ->
  append_items(items_by_category[category_id])

###
Add the given items to the items picker.
###
append_items = (items) ->
  items.forEach (item) ->
    $('#items').append create_button(item.name)

###
Helper function to create a button for each JS Item
###
create_button = (name) ->
  list_item = $('<li>')
  list_item.attr('name', name)
  list_item.addClass 'list-group-item btn btn-default'
  list_item.append name

  list_item.click ->
    toggle_active list_item

  list_item

activate = (elem) ->
  elem.addClass 'active'

deactivate = (elem) ->
  elem.removeClass 'active'

toggle_active = (elem) ->
  if is_active elem
    deactivate elem
  else
    activate elem

form_to_json = (form) ->
  data = {}
  $.each form.serializeArray(), (_, field) ->
    data[field.name] = field.value
  return data

###
Set the height of the first element to the outer height of the second.
###
fit_to = (parent, child) ->
  parent.height outer_height_of(child)

###
Get the height of an element which may or may not be in the DOM.
###
height_of = (elem) ->
  hypothetical_element elem, (e) -> e.height()

###
Get the height of an element (which may or may not be in the DOM) and its padding.
###
outer_height_of = (elem) ->
  hypothetical_element elem, (e) -> e.outerHeight()

###
Perform an operation on an element which may or may not be in the DOM, as if it were. For example,
this can be used to read what the height of an element is going to be before adding it to the DOM.
###
hypothetical_element = (elem, cont) ->
  if $.contains(document, elem)
    return cont elem
  else
    hyp = elem.clone()
    hyp.css 'visibility', 'hidden'

    # Add the (hidden) element to the DOM, do something, then remove it
    $(document.body).append hyp
    res = cont hyp
    hyp.remove()

    return res

all_items = ->
  _.sortBy (_.flatten Object.values(items_by_category), true), 'name'
