# Include routes helpers
<% environment.context_class.instance_eval { include Rails.application.routes.url_helpers } %>

all_items = JSON.parse('<%= raw Item.order(:name).select(:name).to_json %>')

items_by_category = JSON.parse(
  '<%= raw Category.order(:name).map { |category|
    [category.id, category.items.order(:name).select(:name, :id)]
  }.to_h.to_json %>'
)

@init_smooth_scrolling = ->
  # Smooth Scroll on clicking nav items
  $('nav a').click ->
    $href = $(this).attr('href')
    $('body').stop().animate { scrollTop: $($href).offset().top }, 1000
    false
  # back to top
  $('#toTop a').click ->
    $('body').animate { scrollTop: 0 }, 1000
    false
  # Parallaxing + add class active on scroll
  $(document).scroll ->
    # parallaxing
    $movebg = $(window).scrollTop() * -0.3
    $('.portion').css 'background-positionY', $movebg + 'px'
    # add class active to nav a on scroll
    scrollPos = $(document).scrollTop() + 100
    $('nav a').each ->
      currLink = $(this)
      refElement = $(currLink.attr('href'))
      if refElement.position().top <= scrollPos and refElement.position().top + refElement.height() > scrollPos
        $('nav a').removeClass 'active'
        currLink.addClass 'active'
      return
    # changing padding of nav a on scroll
    if scrollPos > 250
      $('nav a').addClass 'small'
      $('nav img').addClass 'move'
      $('nav span').removeClass 'movetext'
    else
      $('nav a').removeClass 'small'
      $('nav img').removeClass 'move'
      $('nav span').addClass 'movetext'
    return

###
Display only items belonging to the given category in the items picker.
If !force, then this founction is a noop if the given category is already displayed. Force can be
specified as a means of refreshing the items picker after an update.
###
@filter_by_category = (category_id, {force} = {}) ->
  force ?= false

  btn = $('#category' + category_id)
  if is_active(btn) and not force
    # We're already filtering by this category
    return
  clear_items()
  append_items_by_category category_id
  activate btn
  return


###
Display all items from all categories in the items picker.
###
@display_all_items = ->
  btn = $('#all_categories')
  if is_active btn
    # We're already displaying all items
    return
  clear_items()
  append_items all_items
  activate btn
  return

###
Set or unset (based on value of select) active class on all the Items within a category
###
@select_all = (select) ->
  $('#items').children('li').each ->
    if is_active($(this)) != select
      toggle_active $(this)

###
Add a new item to the items picker based on the contents of #new-item-form
###
@save_new_item = ->
  item = form_to_json $('#new-item-form')

  if !item.name
    flash_error("Please enter a name for the item.", selector: '#new-item-errors')
    return
  if !item.category_id
    flash_error("Please choose a category for the item.", selector: '#new-item-errors')
    return

  # Tell the server to create the item
  get_json '<%= items_path %>', method: 'POST', data: { item: item }
    .on_success (res) ->
      # Close the dialog
      $('#new-item').modal('hide')

      # Add the new item to the items picker (maintaining sorted order) and filter by its category
      index = _.sortedIndex(items_by_category[item.category_id], item, 'name')
      items_by_category[item.category_id].splice index, 0, item
      filter_by_category(item.category_id, force: true)

      # Scroll to the new item
      first = $('#items li').first().position().top
      elem = $("#items li[name=#{item.name}]").position().top
      $('#items').scrollTop(elem - first);

      # And select it
      activate $("#items li[name=#{item.name}")

      # Let the user know we did it
      flash_success("Item \"#{item.name}\" created")
    .on_error (err) ->
        flash_error(err, selector: '#new-item-errors')

###
Add a new bin to the city based on the contents of #new-bin-form
###
@save_new_bin = ->
  bin = form_to_json $('#new-bin-form')

  if !bin.name
    flash_error('Please enter a name for the bin.')
    return

  get_json '<%= bins_path %>', method: 'POST', data: { bin: bin }
    .on_success (res) ->
      # Add the new bin to our in-browser model
      res.bin.items ?= []
      bins.push res.bin
      # Clear the form
      $('#new-bin-form [name=name]').val('')

      refresh_bins()
      flash_success("Bin \"#{bin.name}\" created.")
    .on_error flash_error

###
Get the category_id by which we are currently filtering, or null if we are not.
###
@active_category = ->
  <% Category.all.each do |category| %>
    if is_active $("#category<%= category.id %>")
      return <%= category.id %>
  <% end %>
    else
      return null

###
Render the data contained in bins
###
@refresh_bins = ->
  last_bin = $("#bins li").last()
  $("#bins li").not(last_bin).html("")

  for bin in bins
    panel = $("<div class=\"panel panel-default\">")
    panel.width(300)

    header = $('<div class="panel-heading">')

    edit_btn = $("<button type=\"button\" class=\"icon\">")
    edit_btn.append $("<span class=\"glyphicon glyphicon-pencil\">")
    header.append edit_btn

    header.append $("<span id=\"bin_#{bin.id}_title\">#{bin.name}</span>")

    delete_btn = $("<button type=\"button\" class=\"close\">&times;</button>")
    header.append delete_btn

    # Bind onclick actions to the edit and delete buttons. We need to capture a different id in each
    # iteration of the loop, so we bind the id in an anonymous function. Thank you Javascript.
    (->
      id = bin.id
      name = bin.name

      edit_btn.click ->
        title = $("#bin_#{id}_title")
        title.html("")

        form = $("<form class=\"inline\">")
        form.width('80%')
        input = $("<input type=\"text\" placeholder=\"Name\" class=\"form-control\" autofocus>")
        input.val(name)
        form.append input
        form.submit (e) ->
          e.preventDefault()
          rename_bin(id, input.val())

        title.append form

      delete_btn.click ->
        delete_bin(id)
    )()

    body = $('<div class="panel-body scrollable-list">')
    body.height(300)
    list = $('<ul class="list-group">')
    list.height('100%')
    for item in bin.items
      list.append create_button item.name
    body.append list

    panel.append header
    panel.append body

    bin_li = $("<li class=\"inline\" name=\"#{bin.name}\">")
    bin_li.append panel

    bin_li.insertBefore(last_bin)

###
Delete the specified bin from the database and the DOM.
###
delete_bin = (id) ->
  get_json "/bins/#{id}", method: 'DELETE'
    .on_success ->
      index = _.findIndex bins, (bin) -> bin.id == id
      if index == -1
        console.log "Unable to remove bin #{id} from GUI"
      else
        bins.splice index, 1
      refresh_bins()

      flash_success 'Bin deleted'
    .on_error flash_error

###
Set the name of the bin with the given id.
###
rename_bin = (id, new_name) ->
  if !new_name
    flash_error 'Please enter a name for the bin.'
    return

  bin = _.find bins, (bin) -> bin.id == id
  unless bin?
    console.log "Could not find bin with id #{id}"
    return

  # Save old name so we can rollback if the transaction fails
  [old_name, bin.name] = [bin.name, new_name]

  get_json "/bins/#{id}", method: 'PATCH', data: { bin: bin }
    .on_success ->
      refresh_bins()
      flash_success "Renamed bin."
    .on_error flash_error
    .on_errors ->
      bin.name = old_name

is_active = (elem) ->
  elem.hasClass 'active'

###
Remove all items from the items picker.
###
clear_items = ->
  $('#items').empty()

  # Unselect the category filter button
  $('#categories').children('li').each -> deactivate $(this)

###
Append all items from the given category to the items picker.
###
append_items_by_category = (category_id) ->
  append_items(items_by_category[category_id])

###
Add the given items to the items picker.
###
append_items = (items) ->
  items.forEach (item) ->
    $('#items').append create_button(item.name)

###
Helper function to create a button for each JS Item
###
create_button = (name) ->
  list_item = $('<li>')
  list_item.attr('name', name)
  list_item.addClass 'list-group-item btn btn-default'
  list_item.append name

  list_item.click ->
    toggle_active list_item

  list_item

activate = (elem) ->
  elem.addClass 'active'

deactivate = (elem) ->
  elem.removeClass 'active'

toggle_active = (elem) ->
  if is_active elem
    deactivate elem
  else
    activate elem

form_to_json = (form) ->
  data = {}
  $.each form.serializeArray(), (_, field) ->
    data[field.name] = field.value
  return data
